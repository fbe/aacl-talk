=== AACL 01 ===
Try overwriting java.lang!

=== AACL 04 - Shading ===
io.netty.util.internal.NativeLibraryLoader.TRY_TO_PATCH_SHADED_ID

private static boolean shouldShadedLibraryIdBePatched(String packagePrefix) {
    return TRY_TO_PATCH_SHADED_ID && PlatformDependent.isOsx() && !packagePrefix.isEmpty();
}

Lol Whut?


Class.forName() breaks isolation
Own module for each class loader


# class loader contains unnamed module!

class forname initializes, but does reflection do that too?

# demo mit noverify und jvm check?

# for slides:
    all classloader contain an own unnamed module - and if you don't use a module classloader its the default like classpath classes.

# delegate to maven in build options

//0) Ein wort zu modules: wir sind im module system und können über auto modules alles tun
1) Delegierende Classloader implementieren (mit synthetischen klassen, das coole byte array oder ASM) (Bild nötig cl hierachie)
2) Delegation Model brechende Classloader implementieren (+ twice loading + cast error)
3) Hibernate Plugin Example (Context Class Loader) (Bild nötig)
4) Shading (Bild nötig) <- 1h
Optional:
5) Klassen Initialisierungsphasen in define class Class -noverify kaputt machen
6) JVM TI: Redefine classes (crack license)
7) Module Isolation brechen ?
